# This module contains the majority of methods/functions used throughout the program as a wholeimport csvimport package_class# This method is used to ascertain whether values passed to it are valid floats. It is used as a part of the loadDistanceData() method# to check for the correct kind of data within the CSV file, then append it to the Data List data structuredef isFloat(value):    try:        float(value)        return True    except ValueError:        return False# This method takes a hashTable and packageID as arguments and returns the correct package from that hashtable for that packageIDdef hashTableLookUp(hashTable, packageID):    print("PackageID, Address, City, State, Zip, Delivery Deadline, Kilograms, Status, DeliveryTime")    return hashTable.search(packageID)# This method takes two arguments, a fileName and a hashTable. It reads through the provided CVS file, then 'loads' it into the# desired hash table. In our specific case, it is called in 'main' to read the file 'WGUPS_package_file.csv', parse its comma separated# values, then create a new package object for each row of data and append it to the provided hash table data structure.def loadPackageData(fileName, hashTable):    with open(fileName, newline='') as packageDataCSV:        packageData = csv.reader(packageDataCSV, delimiter=',')        next(packageData)  # this skips the header information, disregarding it        for packageInfo in packageData:            packageID = int(packageInfo[0])            packageAddress = packageInfo[1]            packageCity = packageInfo[2]            packageState = packageInfo[3]            packageZIP = packageInfo[4]            packageDeadline = packageInfo[5]            packageWeight = packageInfo[6]            packageStatus = "at hub"            # creates new Package object            newPackage = package_class.Package(                packageID,                packageAddress,                packageCity,                packageState,                packageZIP,                packageDeadline,                packageWeight,                packageStatus            )            # inserts newly created Package object into a previously defined hash table with its unique ID            hashTable.insert(packageID, newPackage)# This method, similarly to loadPackageData() above, takes two arguments: a fileName and a list (instead of a hash table). It reads# through the provided CVS file, then 'loads' it into the desired list. In our case, it called in 'main' to read the file# "WGUPS_distance_table.csv", parse its comma separated values along with the isFloat() method, then appends the necessary data to the# provided list one row at a time. As the nature of the provided distance data, the final Distance Data List is a list of increasing# length+=1 arrays. (i.e. 'len(Row 0)==1', len(Row 1)==2, len(Row 2)==3, etc.)def loadDistanceData(fileName, list):    with open(fileName, newline='') as distanceDataCSV:        distanceData = csv.reader(distanceDataCSV, delimiter=',', dialect='unix')        # loops through the distanceDataCSV and appends only the necessary distance data to distanceDataList one row at a time        for distanceInfo in distanceData:            filtered_row = [float(value) for value in distanceInfo if (value != '' and isFloat(value))]            if len(filtered_row) != 0:                list.append(filtered_row)# This method, also similar to loadDistanceData(), takes the same two kinds of arguments, a fileName and a list. In this case, it is# called in 'main' and reads the same previously read file of "WGUPS_distance_table.csv". However, when it parses the comma separated# values, it instead appends ONLY the addresses needed, in the format necessary (such as, to call distanceBetween in 'main'),# to the provided list.def loadAddressData(fileName, list):    with open(fileName, newline='') as addressDataCSV:        addressData = csv.reader(addressDataCSV, delimiter=',', dialect='unix')        for addressInfo in addressData:            # This isn't ideal, but it gets the job done by only appending the data from arrays that DON'T have floats            # in them and only have a length of 2. Appends just the data after the first occurrence of an integer            # which is the necessary part of the address information            if not any(isinstance(element, float) for element in addressInfo) and len(addressInfo) == 2:                # First, 'split' the address then keep everything after the first space                firstDigitIndex = next((index for index, char in enumerate(addressInfo[0]) if char.isdigit()), None)                # If a digit is found, extract the substring after the first digit and append it to the list as the 'address'                if firstDigitIndex is not None:                    addressPart = addressInfo[0][firstDigitIndex:]                    list.append(addressPart)# This method displays the main menu for the command line user interface. It is called in 'main' to display the menu along with other# subsequent options, allowing the user to interact deeper with this program.def displayMenu():    print("Welcome to the WGUPS User Console! What would you like to do?")    print("1. Report ALL Package Information & Truck Mileage")    print("2. View Delivery Status of a Specific Package at a Given Time")    print("3. View Status of ALL Packages at a Given Time")    print("4. Exit")